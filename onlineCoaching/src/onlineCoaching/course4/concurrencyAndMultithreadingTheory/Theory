Concurrency: "the art of doing several things at the same time"

WHat is a Thread?
	A thread is defined at the Operating System level
	A thread is a set of instructions
	An application can be composed of several threads
	Different threads can be executed at the same time
	The JVM works with several threads(GC, JIT, ...)
	
What Does "At the Same Time" Mean?
	
What is happening at the CPU Level
	1st Case: CPU with Only One Core
		It can do one thing at a time
	2nd Case: CPU with Multiple Cores
		It can do two things at the same time 	
		
Who is responsible for the CPU sharing
	A special element called a scheduler
	There are three reasons for the scheduler to pause a thread:
		The CPU should be shared equally among threads
		The thread is waiting for some data
		The thread is waiting for another thread to do something
		
Race Condition	
	Accessing data concurrently may lead to issues!
	It means that two different threads are trying to read and write the same variable at the same time.
	
Example: The Singleton Pattern
	public class Singleton{
		private static Singleton instance;
		private Singleton(){}
		public static Singleton getInstance(){
			if(instance == null){
				instance = new Singleton();
			}
			return instance;
		}	
	} 

What is happening if two threads are calling getInstance()?
	Well Known Race Condition Case:
		
			Thread T1						    Thread T2
	Checks if Instance Is null?				Waiting
			  The answer is yes
			Enters the if block
	
(The thread scheduler pauses T1)
											Checks if instance is null?
											The answer is yes
											Enters the if block
											Creates an Instance of Singleton
											
											(The thread scheduler pauses T2)
Creates an instance of Singleton
(thereby destroying the instance of T2)	

					How to avoid that?
					
The answer is synchronization.													
	Synchronized Example: The Singleton Pattern
		public class Singleton{
			private static Singleton instance;
			private Singleton(){}
			public static synchronized Singleton getInstance(){
				if(instance == null){
					instance = new Singleton();
				}
				return instance;
			}	
		}
																					 	
Under the hood, the Java machine uses a special object, called lock object that has a key
In fact every object in the Java language, has this key, that is used for synchronization.
What does it change to our code? Well, when a thread want to enter this protected method,
it will make a request on this lock object, give me your key. If the lock object has the key
available it will give it to this thread it can run it freely.

So far synchronization to work, we need a special, technical object that will hold the key
In fact, every Java object can play this role
This key is defined internally in the Object class, thus making it available for all the Java objects we define in our apps.
This key is also called a monitor.
Which object is chosen to hold this key?
	public static synchronized Singleton getInstance(){
				if(instance == null){
					instance = new Singleton();
				}
				return instance;
			}
		In this code, the key is the Singleton class itself.
		A synchronized static method uses the class as a synchronization object.
	
	-------------------------------------------------------
	
	if on a non-static method
		public synchronized String getName(){
			return this.name;
		}
	In this code, the key is the instance of the class
	A synchronized non-static method uses the instance as a synchronized object.
	
	-----------------------------------------------------------
	
	A dedicated explicit object to conduct synchronization
		public class Person{
			private final Object key = new Object();
			public String init(){
				synchronized(key){
					//do something
				}
			}
		}
	It is always a good idea to hide an object used for synchronization
		
	---------------------------------------------------------------	
	
	If we really want is to prevent two threads to execute the methods having same name at the same time, in all the instances of the Person class, then we need our lock object to be bound nit to each instance of our class but to the class itself. 
	
--------------------------------------------------------------------

Reentrant Locks and Deadlocks
	What do we mean by Locks Are Reentrant?	
		Suppose we have two instances of Person class, mary and john, and we have a bunch of synchronized method in those instances.
		It turns out, first synchronized method of mary instance calls out other synchronized method of john instance,that happens to be synchronized with the same lock.
		This thread will be allowed.
		When a thread holds a lock, it can enter a block synchronized on the lock it is holding.
		
	What do you mean by Deadlocks?
		Suppose we have two instances of Person class, mary and john,It turns out, first synchronized method of mary instance calls out other synchronized method of john instance.
		but the first method is synchronized with the red key for instance. and the second is synchronized with the green key.
		For some reason this green protected method calls another method (third one) which is also protected by the red key. 
		What will happen?
		The blue thread is going to take the red key,and begin to run this first method. And at the same time, the purple thread is going to take the green key, and to run the 
		other method. At some point, the blue thread will need the green key to enter the green method, but the purple thread has it. So this blue thread has to wait.
		And the purple thread will arrive at the point of code where it needs the red key to continue to run. And unfortunately the red key is not available, because it is held
		by the blue thread. 
		
		Deadlock
			A deadlock is a situation where a thread T1 holds a key needed by a thread T2, and T2 holds the key needed by T1
			
The JVM is able to detect deadlock situations, and can log information to help debug the application.
	
But there is not much we can do if a deadlock situation occurs , beside rebooting the JVM
	
-------------------------------------------------------------------------

Runnable Pattern to Launch Threads
	The most basic way to create threads in Java is to use the Runnable Pattern
	First create an instance of Runnable
	Then pass it to the constructor of the Thread class
	Then call the start() method of this thread object
	
	(Java 7 way)
	Runnable runnable = new Runnable(){
		public void run(){
			String name = Thread.currentThread().getName();
			sysout("I am running in thread " + name);
		}
	}					
				
	(Java 8 way)
	Runnable runnable = () -> {
		String name = Thread.currentThread().getName();
		sysout("I am running in thread " + name);
	}
	
------------------------------------------------------------
	Second, pass it to the constructor of the Thread class
	Third start the thread!
	
	Thread thread = new Thread(runnable);
	thread.start();

------------------------------------------------------------
	
How to lauch a new thread?
	
	@FunctionalInterface
	public interface Runnable{
		void run()
	}
	------------------------
	Runnable task = () -> sysout("Hello world");
	Thread thread = new Thread(task);
	thread.start();
	
	-------------------------------
	
Knowing in which thread a task is executed
	The Thread.currentThread() static method returns the current thread
	---------------------------------
	
How to stop a thread?
	There is a method in the Thread class called stop()
		This method should not be used.
		Once this method was published, its was not possible to remove it on the thread class without introducing a backward incompatibility.
		It is here for legacy.
		
		The right pattern is to use the interrupt() method
-------------------------------------------------------		
Calling interrupt() on a running thread
	The code of the task should call isInterrupted() to terminate itself	
	Thread t1 = ...;
	t1.interrupt();		
	
	Runnable task = () -> {
		while(! Thread.currentThread().isInterrupted()){
			//the task itself
		}
	}
----------------------------------------------------------
Stopping a Thread
	The call to interrupt() causes the isInterrupted() method to return true
	If the thread is blocked, or waiting, then the corresponding method will throw an InterruptedException
	The methods wait()/notify(),join() throw InterruptedException.	
	
----------------------------------------------------------

What is a producer / consumer?
	A producer produces values in a buffer
	A consumer consumes the values from this buffer
	Be careful: the buffer can be empty, or full
	Producer and consumers are run in their own thread
	
	A Simple Producer
		int count = 0;
		int[] buffer = new int[BUFFER_SIZE];
		
		class Producer{
			public void produce(){
				while(isFull(buffer)){}
				buffer[count++] = 1;
			}
		}
		
	A Simple Consumer
		int count = 0;
		int[] buffer = new int[BUFFER_SIZE];
		
		class Consumer{
			public void consume(){
				while(isEmpty(buffer)){}
				buffer[--count] = 0;
			}
		}	
-------------------------------------------------------------

What is wrong with the above code?
	Race condition!
	Several threads are reading and writing the buffer at the same time = race condition
	This will corrupt the array

-------------------------------------------------------------

Fixing the producer / consumer
	One way to fix things is to synchronize the access to the array				
	
	A Simple Producer
		int count = 0;
		int[] buffer = new int[BUFFER_SIZE];
		
		class Producer{
			public void synchronized produce(){
				while(isFull(buffer)){}
				buffer[count++] = 1;
			}
		}
		
	A Simple Consumer
		int count = 0;
		int[] buffer = new int[BUFFER_SIZE];
		
		class Consumer{
			public void synchronized consume(){
				while(isEmpty(buffer)){}
				buffer[--count] = 0;
			}
		}
		
	Will it fix out problems?
		Synchronization can fix our race condition problem, but not if we write it like that
		So we do it like this below.
	-------------------------------------------------------------------		
	private Object lock;
		
		class Consumer{
			public void consume(){
				synchronized(lock){
					while(isEmpty(buffer)){}
					buffer[--count] = 0;
				}
			}
		}
		
		class Producer{
			public void produce(){
				synchronized(lock){
					while(isFull(buffer)){}
					buffer[count++] = 1;
				}
			}
		}		
---------------------------------------------------------------------------------
	This code will work if the lock object is the same for all the producers and consumers
	
	NOW IS IT REALLY FIXED????????????????????????????????

	What happens if the buffer is empty?
		The thread executing this consumer is blocked in the while loop
		So the producer has no chance to add objects to the buffer!
	
	It will lead to deadlock.
-----------------------------------------------------------------------------

Fixing the producer / consumer (again)
	We need a way to "park" a thread while he is waiting for some data to be produced
	Without blocking all the other threads
	So the key held by this thread should be released while this thread is "parked"
	This the wait / notify pattern

------------------------------------------------------------------------------------

Wait / Notify
	wait() and notify() are two methods from the Object class
	They are invoked on a given object
	The thread executing the invocation should hold the key of that object
	So: wait() and notify() cannot be invoked outside a synchronized block
			
Calling wait()
	Calling wait() releases the key held by this thread
	And puts that thread in a WAIT state
	The only way to release a thread from a WAIT state is to notify it

Calling notify()
	Calling notify() releases a Thread in WAIT state and puts it in RUNNABLE state
	This is the only way to release a waiting thread
	The released thread is chosen randomly
	There is also a notifyAll() method			
				
----------------------------------------------------------------------
private Object lock;
		
		class Consumer{
			public void consume(){
				synchronized(lock){
					if(isEmpty(buffer))
						lock.wait();
					buffer[--count] = 0;
					lock.notifyAll();
				}
			}
		}
		
		class Producer{
			public void produce(){
				synchronized(lock){
					if(isFull(buffer))
						lock.wait();
					buffer[count++] = 1;
					lock.notifyAll();
				}
			}
		}

------------------------------------------------------------------------------
 
 A Thread Has A State
 	States --->
 		New
 		 |			Blocked(Waiting at the entrance of a synchronized block)
 		 |			|
 		 |			|
 	  Runnable---------Waiting(Parked using a wait() call)
 	  	 |			|
 	  	 |			|
 	  	 |			Timed_waiting(Parked using a sleep(timeout) or wait(timeout) call)
 	 Terminated	  
 		
 	Getting the state of a thread
 		The getState() method returns a enumerated values of type Thread.State
		Thread t = ...;
		Thread.State state = t.getState();
		
		The State enumeration is a member enumeration of the Thread class
			public enum State{
				NEW,RUNNABLE,TERMINATED,BLOCKED,WAITING,TIME_WAITING;
			}	
		
Ordering read and Write Operations on A Multi-Core CPU
	What is the 'happens before' link?
	What does volatile mean?The impact of 'false sharing' on code
	
Synchronization
	Synchronization protects a block of code
	Guarantees	this code is executed by one thread at a time
	Prevents race condition
----------------------------------------------------------------------
	public void consume(){
		synchronized(lock){
			while(isEmpty(buffer)){}
			buffer[--count] = 0;
		}
	}
	public void produce(){
		synchronized(lock){
			while(isFull(buffer)){}
			buffer[count++] = 1;
		}
	}
	
	lets have a look at the count variable in consume()
		1) reads count from memory
		2) decrement it
		3) writes count back to memory
		
	lets have a look at the count variable in produce()	
		1) reads count from memory
		2) increment it
		3) writes count back to memory
		
		
----------------------------------------------------------------------	
Memory Access
	20 years ago, when CPU had no cache, this code was working fine
	But nowadays, thinks do not work like that any more!
	A CPU does not read a variable from the main memory, but from a cache

----------------------------------------------------------------------
						CPU Architecture			
How does the CPU work with its main memory? Well, we have a first electronic component called CPU, in fact it is called CPU but
there are many sub-CPUs on it called "cores". And there is the main memory,which is different electronic component,
linked to the main CPU using a special bus . On a CPU we may have several cores, suppose we have four.Each cores have several
layers of memory caches called "L1","L2", and a common third layer called "L3".

Why Has It Been Made Like That?
	Because access to caches is much faster than access to main memory because that is limited to speed of bus.
	Access to the main memory: ~100ns
	Access to the L2 cache: 7ns
	Access to the L1 cache: 0.5ns
	
There Are Tradeoffs
	Size of the main memory: several GB
	Size of the L2 cache: 256kB
	Size of the L1 cache: 32kB	
	 		
--------------------------------------------------------------------------
Count with 0 is in main memory
Our producer which is running on Core 1 needs a copy of this count variable,
so this count variable will be copied in the L1 cache of the Core 1 of the CPU.
The Core 1 can modify this variable, that is increment it. But it turns out that Core 2,
which is running the consumer, also needs the same count variable. Now the problem comes
from the fact that the count variable is really stored in two places on my CPU, first in main memory
but the value in there has not been updated yet because the write to this main memory is much, much slower than the write to the 
L1 cache. But my Core 2, since this variable is synchronized, should get the value 1 from the L1 cache of the Core 1 and the not the value 0 from main memory.
So it needs a technical trick here to know that the write value is in the L1 cache of Core 1 and not in the main memory.
This is visibility! 
Visibility is about informing the other caches of my CPU that a variable has been modified and that the write value is in one of the caches of the CPU and should
should not be fetched from the main memory.
-------------------------------------------------------------------------

Visibility
	A variable is said visible 
		if the writes made on it are 'visible' which means that the reads made on this variable are going to return the correct value.
		The nice thing is that all the synchronized writes are visible.
-------------------------------------------------------------------------
"Happens Before" Link
-------------------------------------------------------------------------
The Java Memory Model
	Multicore CPU brings new problems since variable can be stored in multiple places			 
	Read and writes can really happen at the same time
	A given variable can be stored in more than one place
	Visibility means "a read should return the value set by the last write"
	What does last mean in a multicore world?

	We need a timeline to put read and write operations on

So what does the Java Memory Model tells us?
	Suppose we have write operation on Thread T1
		1) T1 writes to x	---->			x = 1	
	Another Thread T2 which is reading this variable. It reads x and copy the value in another variable r.
		2) T2 reads x and copy it to r	---->		r = x
		
		3) What is the value of r?
			
There are two answers and the java memory model fixes these two answers.
	If there is no "happens before" link between the two operations, the value of r is unknown. it should be 1, or 0 which is the default value.
	If there is a "happens before" link between the two operations, the value of r is 1.

How Can We Set Up A "Happens Before" Link?
	There is no such keyword in the Java language...

---------------------------------------------------------------------	
Happens before link
	A "happens before" link exists between all synchronized or volatile write operations and all synchronized or volatile read operations that follow.
		
Happens Before Examples
	Two operations:	
	1) a write operation
	2) a read operation
	
	int index;
	void increment(){
		index++;
	}
	void print(){
		sysout(index);
	}

	What does this code print in multithread?
		Impossible to say.
------------------------------------------------------------
	int index;
	void synchronized increment(){
		index++;
	}
	void synchronized print(){
		sysout(index);
	}

	What does this code print in multithread?
		The correct value is always printed, as the value will be the last value updated by the write operation.
		
	--------------------------------------------------------
	
	volatile int index;
	void increment(){
		index++;
	}
	void print(){
		sysout(index);
	}

	What does this code print in multithread?	
	The variable is volatile --> the correct value is always printed










	