/*
 * Core capabilities of reflection
 * 	Examine types at runtime
 * 	Dynamically execute & access members
 */

/*'
 * The Need for Reflection
 * 	Apps do not always control types used
 * 		Common in advanced app designs
 * 		Common in tools and frameworks
 * 
 * 	Often dynamically load types
 * 		Type not known at compile time
 * 		There's no type-specific source code
 * 
 * 	Requires special runtime type handling
 * 		Examines types at runtime
 * 		Dynamically execute & access members
 */

/*
 * 	Runtime Examination
 * 		Can fully examine objects at runtime
 * 			Type,Base types
 * 			Interfaces implemented
 * 			Members
 * 		Variety of uses
 * 			Determine a type's capabilities
 * 			Tools development
 * 				Type inspector/browser
 * 				Schema generation
 */

/*
 * 	Dynamic Execution and Access
 * 		Can access full capability of type
 * 			Construct instances
 * 			Access fields
 * 			Call methods
 * 		
 * 		Variety of uses
 * 			Configurable application designs
 * 				Specifics tasks externally controlled
 * 			Inversion of control application designs
 * 				App provides fundamental behavior
 * 				Classes added to specialize behavior	
 */

/*
 * 	Type as a Type
 * 		Type is the foundation of any app solution
 * 			We use types to model biz issues or tech issues
 * 
 * 		Java uses types to model type issues
 * 			Fundamental type is the Class class
 * 				Each type has a Class instance
 * 				Describes the type in detail
 */

/*
 * 	Instances of Class class
 * 		simpleName
 * 		fields
 * 		constructors
 * 		methods 
 */

/*
 * 	Accessing a Type's Class instance
 * 		From a type reference
 * 			Call getClass method
 * 		From string name
 * 			Call Class.forName static method
 * 				Pass fully qualified type name
 * 		From type literal
 * 			Use typename.class
 */

/*
 * 	Accessing Type Information
 * 		Every aspect of a type is knowable
 * 			Superclass
 * 			Implemented interfaces
 * 			Modifiers
 * 			Members
 */

package onlineCoaching.RuntimeInfoAndReflection;

public class IntroReflection {
	public static void main(String[] args) throws ClassNotFoundException {
		BankAccount bak1 = new BankAccount("1");
		BankAccount bak2 = new BankAccount("2", 500);
		doWork(bak1);
		HighVolumeAccount hBak1 = new HighVolumeAccount("12");
		classInfo(hBak1);
		
		
		
		//by string name
		Class<?> c = Class.forName("onlineCoaching.RuntimeInfoAndReflection.BankAccount");
		showName(c);
		
//		by type literal
		Class<?> c1 =BankAccount.class;
		showName(c1);
	}
	
	 static void doWork(Object obj) {
		Class<?> c = obj.getClass();
		showName(c);
	}
	
	static void showName(Class<?> theClass) {
		System.out.println(theClass.getSimpleName());
	}
	
	static void classInfo(Object obj) {
		Class<?> theClass = obj.getClass();
		System.out.println(theClass.getSimpleName());
	}
}

class BankAccount{
	private String id;
	private int balance = 0;
	
	 BankAccount(String id) {
		this.id=id;
	}
	
	 BankAccount(String id,int startBalance) {
		balance = startBalance;
		id = "hi";
	}
	
	public String getId() {
		return id;
	}
	
	public int getBalance() {
		return balance;
	}
	
	public void deposit(int amount) {
		balance += amount;
	}
	
	public void withdrawal(int amount) {
		balance -= amount;
	}
}

final class HighVolumeAccount extends BankAccount implements Runnable{

	HighVolumeAccount(String id) {
		super(id);
	}
	
	HighVolumeAccount(String id,int balance) {
		super(id,balance);
	}
	
	private int[] readDailyDeposits() {return null;}
	private int[] readDailyWithdrawals() {return null;}

	@Override
	public void run() {
		for(int depositAmt:readDailyDeposits()) {
			deposit(depositAmt);
		}
		for(int withdrawalAmt:readDailyWithdrawals()) {
			withdrawal(withdrawalAmt);
		}
		
	}
	
}



























